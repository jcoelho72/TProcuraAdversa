<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TProcuraAdversa: Teste Aspirador - Parte 2/2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TProcuraAdversa
   </div>
   <div id="projectbrief">Algoritmos de procura adversa</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('teste_aspirador2.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Teste Aspirador - Parte 2/2</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>| <a href="teste_aspirador1.html">Aspirador 1</a> | <a href="teste_aspirador2.html">Aspirador 2</a> | <a href="teste_puzzle8.html">Puzzle 8</a> | <a href="teste_8damas.html">8 Damas</a> | <a href="teste_particao.html">Partição</a> | <a href="teste_artificial.html">Artificial</a> |</p>
<p>Execução de exemplo com base no problema do Aspirador. Pode acompanhar o teste excutando as ações localmente.</p>
<h2><a class="anchor" id="autotoc_md48"></a>
Sumário</h2>
<ul>
<li><a class="el" href="teste_aspirador2.html#aspirador-a10">Ação 10 - Procura em Profundidade</a></li>
<li><a class="el" href="teste_aspirador2.html#aspirador-a11">Ação 11 - Efetuar uma procura em Profundidade Primeiro</a></li>
<li><a class="el" href="teste_aspirador2.html#aspirador-a12">Ação 12 - Ver uma árvore de procura maior</a></li>
<li><a class="el" href="teste_aspirador2.html#aspirador-a13">Ação 13 - Profundidade Iterativa</a></li>
<li><a class="el" href="teste_aspirador2.html#aspirador-a14">Ação 14 - Profundidade ilimitada</a></li>
<li><a class="el" href="teste_aspirador2.html#aspirador-a15">Ação 15 - Desafio Procura Profundidade</a></li>
</ul>
<div class="fragment"><div class="line">Teste TProcurasConstrutivas</div>
<div class="line">Problema:</div>
<div class="line">  1 - Aspirador</div>
<div class="line">  2 - Puzzle 8</div>
<div class="line">  3 - 8 Damas</div>
<div class="line">  4 - Partição</div>
<div class="line">  5 - Artificial</div>
<div class="line">Opção: 1</div>
</div><!-- fragment --><p>Selecione o problema do Aspirador: <b>1.</b></p>
<p><a class="anchor" id="aspirador-a10"></a></p>
<h2><a class="anchor" id="autotoc_md49"></a>
Ação 10 - Procura em Profundidade</h2>
<p><img src="docs/images/aspirador_profundidade.png" alt="Profundidade Primeiro - expande primeiro os estados mais profundos" class="inline"/></p>
<p>Avançamos agora para a procura em profundidade. Neste caso temos neste algoritmo diversas estratégias. Podemos executar esta procura com um limite de profundidade. Vamos fazer isso na instância 2, que sabemos ter uma solução de 3 movimentos.</p>
<p><a class="anchor" id="aspirador-a11"></a></p>
<h2><a class="anchor" id="autotoc_md50"></a>
Ação 11 - Efetuar uma procura em Profundidade Primeiro</h2>
<p>Utilizar a instância número 2, o algoritmo profundidade primeiro, com limite de profundidade a 3, com nível de debug máximo, e ignorando repetidos: <b>1; 2; 4; 1; 3; 9; 3; 2; 4; 10; 1; <em>ENTER</em>; 5.</b></p>
<p>O parâmetro 1 é o algoritmo, em que o 3 é a profundidade primeiro.</p>
<div class="fragment"><div class="line">Algoritmo base a executar.</div>
<div class="line">1: Largura Primeiro</div>
<div class="line">2: Custo Uniforme</div>
<div class="line">3: Profundidade Primeiro</div>
<div class="line">4: Melhor Primeiro</div>
<div class="line">5: A*</div>
<div class="line">6: IDA*</div>
<div class="line">7: Branch and Bound</div>
<div class="line">Algoritmo (atual 1):</div>
</div><!-- fragment --><p>O parâmetro 9 é o limite, com diferentes interpretações conforme o algoritmo. <br  />
 Na procura em largura o limite servia para limitar o número de estados gerados mas não expandidos. Aqui serve para limitar o nível de profundidade, que é fixado a 3.</p>
<div class="fragment"><div class="line">Opção: 5</div>
<div class="line">g:0</div>
<div class="line"> * [*]</div>
<div class="line">  +g:1 1|2 esq</div>
<div class="line">  |[*] *</div>
<div class="line">  |  +g:2 2|4 dir</div>
<div class="line">  |  | * [*]</div>
<div class="line">  |  |</div>
<div class="line">  |  +g:2 2|4 asp</div>
<div class="line">  |   [.] *</div>
<div class="line">  |</div>
<div class="line">  +g:1 2|4 asp</div>
<div class="line">    * [.]</div>
<div class="line">     +g:2 3|6 esq</div>
<div class="line">     |[*] .</div>
<div class="line">     |</div>
<div class="line">     +g:2 3|6 asp</div>
<div class="line">       * [.]</div>
<div class="line"> </div>
<div class="line">P1:3 P2:4 P3:1 P4:1 P5:10 P6:0 P7:0 P8:0 P9:3 P10:1</div>
<div class="line">P11:100 P12:0 P13:0</div>
<div class="line">Resultado: -1 (0,012s)</div>
<div class="line">Aspirador</div>
<div class="line">P1(Algoritmo): Profundidade Primeiro | P2(Debug): completo | P3(Ver): 1 | P4(Seed): 1</div>
<div class="line">P5(Tempo): 10 | P6(Gerações): 0 | P7(Expansões): 0 | P8(Avaliações): 0</div>
<div class="line">P9(Limite): 3 | P10(Repetidos): ignorar | P11(pesoAStar): 100 | P12(ruido): 0</div>
<div class="line">P13(baralhar): 0</div>
<div class="line">[Estatísticas] expansões 3 | gerações 6 | avaliações 0</div>
<div class="line"> * [*]</div>
<div class="line">_______________________________________________________________________________</div>
<div class="line">| 1 - Inicializar | 2 - Explorar | 3 - Solução/Caminho |</div>
<div class="line">| 4 - Parâmetros  | 5 - Executar | 6 - Configurações   | 7 - Teste</div>
</div><!-- fragment --><p>Podemos ver todos os estados gerados. A árvore tendo 3 níveis, permite dois movimentos, pelo que não foi descoberta a solução, retornando -1. Este resultado pode ser utilizado para saber que não há nenhuma solução de comprimento inferior a 3, ou seja, é um lower bound.</p>
<p>Esta visualização da árvore da procura é interessante para pequenos problemas, mas naturalmente que procuras maiores torna-se impraticável. Podemos observar aqui que o estado inicial foi gerado novamente, dado que estamos a ignorar os repetidos.</p>
<p><a class="anchor" id="aspirador-a12"></a></p>
<h2><a class="anchor" id="autotoc_md51"></a>
Ação 12 - Ver uma árvore de procura maior</h2>
<p>Colocar a profundidade a 10, e o nível de debug a 3: <b>1; 2; 4; 9; 10; 2; 3; <em>ENTER</em>; 5.</b></p>
<div class="fragment"><div class="line">Opção: 5</div>
<div class="line">--+--+--+--+--+--+--+--+--+= g:9 9|18</div>
<div class="line">  |  |  |  |  |  |  |  |  |[*] *</div>
<div class="line">  |  |  |  |  |  |  |  |  += g:9 9|18</div>
<div class="line">  |  |  |  |  |  |  |  |    * [.]</div>
<div class="line">  |  |  |  |  |  |  |  +--+= g:9 10|20</div>
<div class="line">  |  |  |  |  |  |  |     | . [*]</div>
<div class="line">  |  |  |  |  |  |  |     += g:9 10|20</div>
<div class="line">  |  |  |  |  |  |  |      [.] *</div>
<div class="line">  |  |  |  |  |  |  +--+--+= g:9 12|24</div>
<div class="line">  |  |  |  |  |  |     |  | * [.]</div>
<div class="line">  |  |  |  |  |  |     |  + Solução encontrada!</div>
<div class="line">[.] . (g:9)</div>
<div class="line">P1:3 P2:3 P3:1 P4:1 P5:10 P6:0 P7:0 P8:0 P9:10 P10:1</div>
<div class="line">P11:100 P12:0 P13:0</div>
<div class="line">Resultado: 9 (0,021s)</div>
<div class="line">Aspirador</div>
<div class="line">P1(Algoritmo): Profundidade Primeiro | P2(Debug): detalhe | P3(Ver): 1 | P4(Seed): 1</div>
<div class="line">P5(Tempo): 10 | P6(Gerações): 0 | P7(Expansões): 0 | P8(Avaliações): 0</div>
<div class="line">P9(Limite): 10 | P10(Repetidos): ignorar | P11(pesoAStar): 100 | P12(ruido): 0</div>
<div class="line">P13(baralhar): 0</div>
<div class="line">[Estatísticas] expansões 12 | gerações 24 | avaliações 0</div>
<div class="line">[.] .</div>
<div class="line">_______________________________________________________________________________</div>
</div><!-- fragment --><p> Com o nível debug a 3 vemos a árvore de procura apenas os estados folha, mas não os estados expandidos. A informação é mais reduzida, mas poderá ser uma boa forma de analisar os estados em que o algoritmo volta para trás, já que podem ter alguma característica relevante, ainda não implementada. A solução não é óptima, tem comprimento 9! Podemos visualizar a solução, introduza: <b>3.</b></p>
<div class="fragment"><div class="line">Opção: 3</div>
<div class="line"> </div>
<div class="line"> * [*] (g:0)</div>
<div class="line">[*] *  (g:1)</div>
<div class="line"> * [*] (g:2)</div>
<div class="line">[*] *  (g:3)</div>
<div class="line"> * [*] (g:4)</div>
<div class="line">[*] *  (g:5)</div>
<div class="line"> * [*] (g:6)</div>
<div class="line"> * [.] (g:7)</div>
<div class="line">[*] .  (g:8)</div>
<div class="line">[.] .  (g:9)</div>
</div><!-- fragment --><p>Como o algoritmo é cego, segue a ordem dos sucessores. Neste caso está sempre a trocar de posição antes de aspirar. Apenas foi ver as alternativas quando teve de voltar para trás, devido ao limite de profundidade. Se tivéssemos escolhido uma profundidade menor, a solução obtida seria também menor. Mas se a profundidade fosse menor que a solução mais curta, não iriamos obter nenhuma solução. É com base nesse dilema que surge a procura em profundidade iterativa, no caso deste código é executada com o limite=0.</p>
<p><a class="anchor" id="aspirador-a13"></a></p>
<h2><a class="anchor" id="autotoc_md52"></a>
Ação 13 - Profundidade Iterativa</h2>
<p>Colocar a profundidade iterativa (limite a 0), e o nível de debug a 2: <b>1; 2; 4; 9; 0; 2; 2; <em>ENTER</em>; 5.</b></p>
<div class="fragment"><div class="line">Iteração 1:</div>
<div class="line">= g:0</div>
<div class="line">Iteração 2:</div>
<div class="line">--+= g:1 1|2</div>
<div class="line">  += g:1 1|2</div>
<div class="line">Iteração 3:</div>
<div class="line">--+--+= g:2 3|6</div>
<div class="line">  |  += g:2 3|6</div>
<div class="line">  +--+= g:2 4|8</div>
<div class="line">     += g:2 4|8</div>
<div class="line">Iteração 4:</div>
<div class="line">--+--+--+= g:3 7|14</div>
<div class="line">  |  |  += g:3 7|14</div>
<div class="line">  |  +--+= g:3 8|16</div>
<div class="line">  |     += g:3 8|16</div>
<div class="line">  +--+--+= g:3 10|20</div>
<div class="line">     |  + Solução encontrada!</div>
<div class="line">[.] . (g:3)</div>
<div class="line">P1:3 P2:2 P3:1 P4:1 P5:10 P6:0 P7:0 P8:0 P9:0 P10:1</div>
<div class="line">P11:100 P12:0 P13:0</div>
<div class="line">Resultado: 3 (0,016s)</div>
<div class="line">Aspirador</div>
<div class="line">P1(Algoritmo): Profundidade Primeiro | P2(Debug): passos | P3(Ver): 1 | P4(Seed): 1</div>
<div class="line">P5(Tempo): 10 | P6(Gerações): 0 | P7(Expansões): 0 | P8(Avaliações): 0</div>
<div class="line">P9(Limite): 0 | P10(Repetidos): ignorar | P11(pesoAStar): 100 | P12(ruido): 0</div>
<div class="line">P13(baralhar): 0</div>
<div class="line">[Estatísticas] expansões 10 | gerações 20 | avaliações 0</div>
<div class="line">[.] .</div>
<div class="line">_______________________________________________________________________________</div>
</div><!-- fragment --><p>Podemos observar que o algoritmo encontrou a solução de comprimento 3, a solução ótima. Fez várias iterações que não serviram para nada, antes de executar na iteração 4 com limite a 4. Mas essas árvores de procura são muito mais pequenas, pelo que o peso de executar essas procuras extra não é muito relevante.</p>
<p>Podemos ver também a versão compactada da árvore de procura, contendo apenas informação do estado, tal como na procura em largura, mas desta vez com informação de onde o estado veio. Pela observação da árvore é possível verificar que a maior parte das ramificações são de dois sucessores, o que é natural dado que este problema tem apenas duas salas.</p>
<p>Vamos agora ver o que acontece se não limitarmos a procura em profundidade, colocando o limite=-1</p>
<p><a class="anchor" id="aspirador-a14"></a></p>
<h2><a class="anchor" id="autotoc_md53"></a>
Ação 14 - Profundidade ilimitada</h2>
<p>Colocar a profundidade ilimitada (limite a -1), e o nível de debug a 1: <b>1; 2; 4; 9; -1; 2; 1; <em>ENTER</em>; 5.</b></p>
<div class="fragment"><div class="line">Opção: 5</div>
<div class="line">########</div>
</div><!-- fragment --><p>Temos um crash do programa, e bem cedo. Como a procura em profundidade está implementada de forma recursiva, houve um problema no stack. Se tivesse implementada com listas, teríamos um problema de memória, como na procura em largura. Entrou-se num ramo infinito, mesmo neste pequeno problema, como aliás é possível imaginar na solução da procura com nível 10.</p>
<p><a class="anchor" id="aspirador-a15"></a></p>
<h2><a class="anchor" id="autotoc_md54"></a>
Ação 15 - Desafio Procura Profundidade</h2>
<p>Lembra-se de algo dado na procura em largura, que impede ciclos infinitos e poderia permitir o uso da procura em profundidade ilimitada?</p>
<details >
<summary >
Resposta</summary>
<p>Sim, não ignorar os estados repetidos não servem apenas para reduzir a árvore de procura. Evitam também ciclos infinitos. Com repetidos nos ascendentes ou gerados, consegue resolver com a procura em profundidade ilimitada, qualquer uma das 50 instâncias. </p>
</details>
<p>Está terminado esta execução de exemplo. Este problema tem uma heurística perfeita, pelo que, qualquer algoritmo informado encontra a solução ótima sem nunca se enganar. Iremos em outros problemas testar os algoritmos informados.</p>
<p>O custo de cada ação é sempre unitário, pelo que, o custo uniforme será mostrado num problema em que cada ação possa ter custo variável. Deixamos também as configurações e os testes empíricos, com as opções 6 e 7 do menu dos testes manuais, para outros problemas.</p>
<p>| <a href="teste_aspirador1.html">Aspirador 1</a> | <a href="teste_aspirador2.html">Aspirador 2</a> | <a href="teste_puzzle8.html">Puzzle 8</a> | <a href="teste_8damas.html">8 Damas</a> | <a href="teste_particao.html">Partição</a> | <a href="teste_artificial.html">Artificial</a> | </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
